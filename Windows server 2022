Nice — I’ll generate **(A)** a safe, professional, step-by-step README you can put in a GitHub repo (detailed but sanitized), and **(B)** a short LinkedIn post you can copy-paste. I’ll also include the important `nmap` starting commands you asked for and keep everything explicitly labeled as *lab-only*. I used details from your uploaded PDF when useful. 

---

# A — GitHub README (sanitized, step-by-step)

> **Title:** WinServer2022-WinRM-Lab (learning lab)
> **Important:** All steps were performed **in an isolated VMware lab** owned by me (Kali Linux attacker VM → Windows Server 2022 target VM). Do **not** run these steps against systems you do not own or have written permission to test.

## Overview

This repository documents a hands-on learning exercise in which I discovered and interacted with a WinRM service (HTTP 5985) on a Windows Server 2022 VM. The goal was **education**: service discovery, safe fingerprinting, credentialed enumeration (when authorized), and remediation recommendations. No production targets were involved. 

---

## Lab scope & safe-use statement

* **Scope:** Single host (Windows Server 2022 VM) on an isolated VMware network (host-only or NAT).
* **Purpose:** Practice reconnaissance and secure configuration (WinRM hardening).
* **Do not publish:** real credentials, exploit payloads, live IPs, or any instructions that could be used on third-party systems.

---

## Lab setup (high level)

* Host: Personal machine running VMware Workstation / Player.
* Attacker VM: Kali Linux (latest).
* Target VM: Windows Server 2022 (fully owned).
* Network mode: **Host-only** or **NAT** (ensure target not accessible from the Internet).

---

## Tools used (names only)

* nmap, curl, evil-winrm (or native Windows remoting tools), basic shell utilities. 

---

## Step-by-step procedure (sanitized)

> Replace `TARGET` with your target IP or hostname in your **isolated lab**. Use hostnames for Kerberos workflows.

### 1) Fast discovery — full TCP port sweep (starting `nmap`)

Start with a stealthy/full TCP port scan to find open services:

```bash
# Fast, full-port TCP SYN scan (use sudo for raw sockets)
sudo nmap -sS -Pn -p- -T4 TARGET
```

This discovers open ports across the host. (If you already know the target port, you can skip the `-p-` full-port scan and scan only specific ports.)

### 2) Service/version discovery on interesting ports

Once you find an open port (e.g., `5985` for WinRM over HTTP), run service/version detection:

```bash
# Service & banner probes for a specific port (example: 5985)
nmap -sV -p 5985 --script=banner,http-title TARGET
```

This provides banners and web titles and helps confirm WinRM. (Your notes used a similar `nmap -sV -p 5985 --script=banner,http-title` scan). 

### 3) Passive fingerprinting with HTTP/GET

Check the service endpoint with a safe GET to gather basic info:

```bash
curl -v http://TARGET:5985/wsman
```

If the server expects a POST, you’ll typically see a short response or an HTTP `405/401`. The GET helps confirm the endpoint presence. 

### 4) SOAP Identify using POST (fingerprinting)

A POST with a WS-Man `Identify` SOAP envelope can reveal product/version info **if allowed**. Save the SOAP body to a file and POST it:

```bash
cat > identify.xml <<'EOF'
<?xml version="1.0" encoding="utf-8"?>
<s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope"
            xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"
            xmlns:wsman="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd">
  <s:Header>
    <wsa:Action>http://schemas.xmlsoap.org/ws/2004/09/transfer/Identify</wsa:Action>
    <wsa:To>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</wsa:To>
  </s:Header>
  <s:Body>
    <Identify xmlns="http://schemas.xmlsoap.org/ws/2004/09/transfer"/>
  </s:Body>
</s:Envelope>
EOF

curl -v -X POST 'http://TARGET:5985/wsman' \
  -H 'Content-Type: application/soap+xml;charset=UTF-8' \
  --data-binary @identify.xml
```

**Expected results:**

* `401 Unauthorized` with `WWW-Authenticate` headers (Negotiate/NTLM/Basic) → auth required.
* `200 OK` with a SOAP `IdentifyResponse` → service reveals server/product/version details. These behaviors are described in your lab notes. 

### 5) Credentialed enumeration (only if you are authorized / have creds)

If you own the VM or have explicit permission and valid credentials, use proper tools (Windows native remoting, `evil-winrm`, or `Test-WSMan`) for credentialed tests:

```bash
# Example using evil-winrm (replace creds and IP)
evil-winrm -i TARGET -u Administrator -p 'YourPassword'
```

or, from Windows:

```powershell
Test-WSMan -ComputerName winhost.example.local
winrm get winrm/config
Get-ChildItem -Path WSMan:\localhost\Service | Format-List *
```

**Do not** attempt brute force, relay attacks, or password spraying unless you have explicit written authorization. 

### 6) If Kerberos is applicable (domain-joined)

Use hostname + Kerberos ticket rather than IP:

```bash
# On attacker machine: get a TGT (kinit) then use curl negotiate
kinit administrator@EXAMPLE.LOCAL
curl -v --negotiate -u : \
  -H "Content-Type: application/soap+xml;charset=UTF-8" \
  --data-binary @identify.xml \
  "http://winhost.example.local:5985/wsman"
```

Kerberos requires correct SPN/hostname resolution (DNS or /etc/hosts). 

---

## Findings (example / high level)

* Service detected: **WinRM (HTTP) on port 5985**.
* Response behavior: typical `401` with `WWW-Authenticate: Negotiate, NTLM` when auth required, or `200` with IdentifyResponse if anonymous identify allowed. (See lab notes.) 

---

## Remediation & hardening recommendations

* Disable WinRM HTTP (5985) on exposed hosts; prefer WinRM over **HTTPS (5986)**.
* Restrict management ports to management network or jump hosts via firewall rules.
* Enforce strong administrative passwords and MFA for accounts with remote privileges.
* Prefer Kerberos (and disable NTLM where possible).
* Monitor Windows event logs for unusual WinRM activity. 

---
